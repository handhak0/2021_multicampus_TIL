# 📕 자료구조 



# 02. 자료구조와 알고리즘

## 알고리즘 표현법 

### 의사코드를 이용한 표현 

```python
: 레이블1 
 
if 트럭을 태울 수 있다면 : 
    put on a truck <- animal 
else : 
    put in the fence <- animal 
 
```

- 이렇게 만들면, 하나의 언어에서만 쓸 수 있는 것이 아니라 모든 언어에서 사용이 가능하다. 





## 알고리즘의 성능 

### 알고리즘 성능 측정 

- 시간 복잡도 : 컴퓨터가 처리하는데 얼마나 걸리는 지 

- 1에서 100까지 더한다면? 

```python
# 알고리즘 1번 
result = 0
for i in range(1,101) : 
    result = result + i 
print(result)

# 알고리즘 2번 

result = 0
result = (1+100)*(100) / 2 
print(result)
```

- 알고리즘 1번 : 연산의 횟수가 102번이지만, 퉁 쳐서 100번임 - 개수가 늘어날 때마다 시간이 늘어남 O(N)
- 알고리즘 2번 : 연산의 횟수가 1번임 - 개수의 상관없이 무조건 연산은 한 번 O(1)



### 알고리즘의 성능 표기 

- 빅-오 표기법 O(f(n)) 
- O(1), O(log n), O(n), O(n log n), O(n^2), O(n^3), O(2^n)

![image-20210821103110896](C:\Users\sonso\Desktop\Python\멀티캠퍼스\00.TIL\00.Spcial_Lecture\md-images\image-20210821103110896-16295094735981.png)



### 자료구조와 알고리즘과 프로그램의 관계 

- 자료구조 : 자동차 부품 
- 알고리즘 : 자동차 조립 방법
- 프로그래밍 언어 : 자동차 조립
- 소프트웨어 : 완성 자동차 



## 자료구조의 종류 

- (단순) 
- 선형 : 리스트(단순 / 연결), 스택, 큐  # 파이썬에서의 리스트는 배열이라고 생각하면 좋음 
- 비선형 : 트리, 그래프
- (파일)



---



# 03.  선형 리스트

## 선형리스트란? 

- 데이터를 일정한순서로 나열한 자료구조
- 순차리스트(Ordered list) 라고도함 
- 선형 리스트는 입력 순서대로 저장하는 데이터에 적당 



#### Code 

- code03_01~04



# 04. 단순 연결 리스트 

## 단순 연결 리스트란? 

- 방문할 맛집을 지도에 순서대로 연결한 것처럼, 떨어진 곳에 위치한 데이터를 화살표로 연결한 것 
- 노드들이 물리적으로 떨어진 곳에 위치 
- 각 노드의 번지도 순차적이지 않음
- 화살표로 표시된 **연결(링크, link)**을 다라가면 선형 리스트 순서와 같음 



## 왜 사용하는가? 

- 데이터를 삽입/ 삭제할 때
  - 선형 리스트는 많은 작업이 필요(오버헤드 발생)
  - 단순 연결 리스트는 해당 노드의 앞뒤 링크만 수정하면 되므로 `오버헤드`가 거의 발생하지 않음 
  - 오버헤드 : 엄청나게 오래 걸리는 시간 

![image-20210821132956946](C:\Users\sonso\Desktop\Python\멀티캠퍼스\00.TIL\00.Spcial_Lecture\md-images\image-20210821132956946-16295201983532.png)

## 단순 연결 리스트의 원리 

### 노드 구조 

`code04_01`

- 노드 : 데이터 + 링크로 구성된 항목 

- head : 연결리스트의 맨 처음 데이터를 가리키는 변수 

  ![image-20210821133204980](C:\Users\sonso\Desktop\Python\멀티캠퍼스\00.TIL\00.Spcial_Lecture\md-images\image-20210821133204980-16295203264143.png) 

- 끝은 링크가 비어있다. 

- 따라서, head만 따라가면 연결리스트의 끝까지 알 수 있다. 



### 노드(데이터) 삽입

- 새 노드 생성 

  - class node 데이터형 정의 

  ```python
  Class Node() : 
      def __init__(self) : 
          self.data = None
          self.link = None
  ```

  - 새 노드에 클래스 노드 부여 

- 링크 수정 



### 노드(데이터) 삭제 

- 링크 수정 

- 노드 삭제 

  

## 일반 형태 

`code04_02`

- head : 첫 번재 노드 

- current : 지금 처리 중인 노드 

- pre : 현재 처리 중인 노드의 바로 앞 노드 

  

## 노드 삽입 

- 첫 번째 노드 삽입 
- 중간 노드 삽입 





# 06. 스택 

## 스택의 개념 

- 한쪽 끝이 막힌 형태 



## 스택 원리 

- 삽입 : push `code06_01`
- 추출 : pop
- 가장 위의 데이터 : top 



# 07. 큐

## 큐의 개념 

- 입구와 출구가 따로 있는 원통 형태 



## 큐의 문제점 

- 앞에 비어있어도 사용하지 못한다는 문제점 
- 해결책 : 데이터를 앞으로 옮긴다. 
- 그렇다면? 언제 옮기는가?? 
- 앞이 비었을 때 = front가 -1이 아닐 때 
- 하지만 이것도 문제가 데이터가 많아지면 오버헤드가 생김 
- 해결책 : 원형 큐 





## 원형 큐 

- 원형 큐가 빈 경우 





# 08. 이진트리 

## 트리 구조란 ? 

직책 구조가 대표적인 트리구조 



## 이진 트리의 개념 

나무를 거꾸로 뒤집어 놓은 형태 



- 트리 자료구조 용어 

  - 루트 노드 

    *노드 : 연결형 자료구조 

  - 부모 노드, 자식 노드 

  - 엣지 : 연결된 선 

  - 차수 : 자식의 개수 

  - 리프 노드 : 맨 마지막 노드 = 자식이 없는 노드 = 차수가 0인 노드 

- 이진 트리 : 자식노드가 `최대 2개`인 트리 

  - 왼쪽 서브 트리
  - 오른쪽 서브 트리 
  - 높이 : 트리의 높이 



## 이진 트리의 종류 

### 포화 이진 트리 

- 자리 없이 꽉 찬 포화 이진 트리 
- 번호는 왼쪽에서 오른쪽으로 매겨짐 

### 완전 이진 트리 

- 빈 게 있지만 
- 번호는 똑같이 왼쪽에서 오른쪽으로 매겨짐 

### 일반 이진 트리 

- 빈 게 있고, 
- 번호가 빠진 게 있음 

### 편향 이진 트리 

- 한 쪽으로만 트리가 구성된 것 



## 이진 트리의 기본 

### 이진 트리의 노드 구조 

- 왼쪽 링크 
- 데이터 
- 오른쪽 링크 



### 이진 탐색 트리의 생성 

![image-20210828141105586](C:\Users\sonso\Desktop\Git\멀티캠퍼스\00.TIL\00.Spcial_Lecture\md-images\image-20210828141105586.png)

맨 처음 노드만 잡고 있으면, 모든 트리로 탐색이 가능하다. 

- 작은 애는 왼쪽으로, 큰 애는 오른쪽으로 보낸다. 





# 09. 그래프 

## 그래프 구조란? 

- 마구잡이로 연결되어 있는 구조 

- 트리는 그래프의 일종인데, 구현이 다름 그래서 별개로 생각함 

- 그래프는 루트 노드 개념이 없다. 



## 그래프 종류 

![image-20210828151400612](C:\Users\sonso\Desktop\Git\멀티캠퍼스\00.TIL\00.Spcial_Lecture\md-images\image-20210828151400612.png)

### 무방향 그래프 

- G1 그래프 
  - 정점 : A, B, C, D
  - 간선 = 엣지 : A-B, A-C, ... 
- G2 그래프 
  - 정점 : A,B,C,D
  - 간선 = 엣지 : A-B, B-D

### 방향 그래프 



### 가중치 그래프 

- 간선마다 가중치가 다르게 부여된 그래프 



## 그래프의 기본 

### 깊이 우선 탐색

- 문별 - 솔라 - 쯔위 - 선미 - 화사 (끝) - 선미 - 쯔위 - 휘인 (끝) - 쯔위 (끝) - 솔라 (끝) - 문별 (끝)

### 너비 우선 탐색 





## 그래프의 인접 행렬 표현 

- 그래프를 코드로 구현할 때는 인접 행렬을 사용 
- 인접 행렬은 정방형으로 구성된 행렬로 정점인 4개인 그래프는 4*4로 표현 
- 자기자신이랑의 연결은 없으니 0으로 채우기 
- 연결된 애들끼리의 값은 1로 채우기 



- 무방향 그래프의 인접행렬은 대각선을 기준으로 `서로 대칭`된다 



---



# 📒 알고리즘 



# 10. 재귀 알고리즘 

> 똑같은 호출이 계속 반복되는 것 마트료시카 인형처럼 동일한 작동을 무한적으로 반복 



## 재귀 호출의 개념 

: 자신을 다시 호출하는 것 



## 기본

무한반복 후 돌아가는 것이 필요









# 11. 정렬 알고리즘 

> 차례대로 줄세우기 (오름차순, 내림차순)

## 선택 정렬 

### 개념 

: 여러 데이터 중에서 가장 작은 값을 뽑는 것을 반복하여 값을 정렬 

- 배열의 첫 번째 값을 가장 작은 값으로 지정한다 
- 다음 차례 값과 비교하여 변경 



**개선된 선택 정렬**

- 작은 거 앞으로 보내고 나머지끼리 비교해서 또 작은 거 앞으로 보내고 ... 

## 삽입 정렬 

## 버블 정렬 

## 퀵 정렬 

> 위의 세 가지 정렬은 똑같고, 얘가 빠름 





# 12. 검색 알고리즘 

> 검색은 정렬된 상태에서 원하는 것을 찾는 것 



## 순차 검색 

- 검색할 집합이 정렬되어 있지 않은 상태일 때, 
- 처음부터 차례대로 찾아보는 것으로, 쉽지만 비효율적임 



## 이진 검색 

- 이미 정렬되어 있는 것
- 순차검색보다 효율적 

### 이진 검색의 원리와 시간복잡도 

- 전제 조건 : 정렬되어 있음 
- 이진 검색은 전체를 반씩 잘라내서 한 쪽을 버리는 방식을 사용 
  - 반을 딱 잘라서, 찾는 애보다 커 작어? 해서 크면 오른쪽 반 버려! 
  - 또 반을 잘라서, 찾는 애보다 커 작어? 해서 작으면 왼쪽 반 버려! 
  - 이걸 반복하는 것 
- 엄청나게 데이터가 많더라도 굉장히 빠른 효율적인 알고리즘이다



## 트리 검색 

- 데이터 검색에는 상당히 효율적이지만 트리의 삽입, 삭제 등에는 부담 







# 📘 최종 정리 

## 자료구조 

- 선형 : 선형 리스트, 연결 리스트, 스택, 일반 큐, 원형 큐, 트리, 그래프 
- 비선형 : 트리(이진 탐색 트리), 그래프(연관배열)



## 알고리즘 

- 정렬 : 선택 정렬 (배열 2개 사용 ---> 배열 1개 사용)
- 검색 : 이진 검색 
- 재귀 



[카페](https://cafe.naver.com/algoryStudy)





